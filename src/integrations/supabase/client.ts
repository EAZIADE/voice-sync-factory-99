
// This file is automatically generated. Do not edit it directly.
import { createClient } from '@supabase/supabase-js';
import type { Database } from './types';

const SUPABASE_URL = "https://cvfqcvytoobplgracobg.supabase.co";
const SUPABASE_PUBLISHABLE_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImN2ZnFjdnl0b29icGxncmFjb2JnIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDMwMTY4NjksImV4cCI6MjA1ODU5Mjg2OX0.k6ho8-LWVYgMAbmu2_pViojgJN51FoWdPREqD-p9htw";

// Import the supabase client like this:
// import { supabase } from "@/integrations/supabase/client";

export const supabase = createClient<Database>(SUPABASE_URL, SUPABASE_PUBLISHABLE_KEY);

// Storage bucket constants
const PODCASTS_BUCKET = 'podcasts';

/**
 * Ensures the podcasts storage bucket exists
 * @returns Promise<boolean> - Whether the bucket exists or was created successfully
 */
export const ensurePodcastsBucketExists = async (): Promise<boolean> => {
  try {
    // Check if bucket already exists
    const { data: buckets, error: listError } = await supabase
      .storage
      .listBuckets();
      
    if (listError) {
      console.error("Error checking for podcasts bucket:", listError);
      return false;
    }
    
    const bucketExists = buckets?.some(bucket => bucket.name === PODCASTS_BUCKET);
    
    if (bucketExists) {
      console.log("Podcasts bucket already exists");
      return true;
    }
    
    // Create bucket if it doesn't exist
    const { error: createError } = await supabase
      .storage
      .createBucket(PODCASTS_BUCKET, {
        public: true,
        fileSizeLimit: 52428800, // 50MB
      });
      
    if (createError) {
      console.error("Error creating podcasts bucket:", createError);
      return false;
    }
    
    console.log("Podcasts bucket created successfully");
    return true;
  } catch (err) {
    console.error("Error ensuring podcasts bucket exists:", err);
    return false;
  }
};

/**
 * Checks if a media file exists for a project
 * @param projectId - The ID of the project
 * @param type - The type of media ('video' or 'audio')
 * @returns Promise<boolean> - Whether the file exists
 */
export const checkMediaFileExists = async (projectId: string, type: 'video' | 'audio'): Promise<boolean> => {
  try {
    const filePath = `${projectId}/${type}.${type === 'video' ? 'mp4' : 'mp3'}`;
    const { data, error } = await supabase
      .storage
      .from(PODCASTS_BUCKET)
      .list(projectId, {
        search: type === 'video' ? 'video.mp4' : 'audio.mp3'
      });
      
    if (error) {
      console.error(`Error checking if ${type} file exists:`, error);
      return false;
    }
    
    return data && data.length > 0;
  } catch (err) {
    console.error(`Error checking if ${type} file exists:`, err);
    return false;
  }
};

/**
 * Gets the public URL for a media file
 * @param projectId - The ID of the project
 * @param type - The type of media ('video' or 'audio')
 * @returns string - The public URL of the file
 */
export const getMediaUrl = (projectId: string, type: 'video' | 'audio'): string => {
  const filePath = `${projectId}/${type}.${type === 'video' ? 'mp4' : 'mp3'}`;
  
  const { data } = supabase
    .storage
    .from(PODCASTS_BUCKET)
    .getPublicUrl(filePath);
    
  return data.publicUrl;
};

/**
 * Gets a signed URL for a media file
 * @param projectId - The ID of the project
 * @param type - The type of media ('video' or 'audio')
 * @returns Promise<string | null> - The signed URL of the file
 */
export const getSignedUrl = async (projectId: string, type: 'video' | 'audio'): Promise<string | null> => {
  try {
    const filePath = `${projectId}/${type}.${type === 'video' ? 'mp4' : 'mp3'}`;
    
    const { data, error } = await supabase
      .storage
      .from(PODCASTS_BUCKET)
      .createSignedUrl(filePath, 60 * 60); // 1 hour expiry
      
    if (error) {
      console.error(`Error creating signed URL for ${type}:`, error);
      return null;
    }
    
    return data.signedUrl;
  } catch (err) {
    console.error(`Error getting signed URL for ${type}:`, err);
    return null;
  }
};

/**
 * Downloads a media file as a blob
 * @param projectId - The ID of the project
 * @param type - The type of media ('video' or 'audio')
 * @returns Promise<Blob | null> - The file as a blob
 */
export const downloadMediaBlob = async (projectId: string, type: 'video' | 'audio'): Promise<Blob | null> => {
  try {
    const filePath = `${projectId}/${type}.${type === 'video' ? 'mp4' : 'mp3'}`;
    
    const { data, error } = await supabase
      .storage
      .from(PODCASTS_BUCKET)
      .download(filePath);
      
    if (error) {
      console.error(`Error downloading ${type}:`, error);
      return null;
    }
    
    return data;
  } catch (err) {
    console.error(`Error downloading ${type}:`, err);
    return null;
  }
};

/**
 * Downloads a media file
 * @param projectId - The ID of the project
 * @param type - The type of media ('video' or 'audio')
 * @returns Promise<{success: boolean, url?: string, message?: string}> - Result of the download operation
 */
export const downloadMediaFile = async (projectId: string, type: 'video' | 'audio'): Promise<{success: boolean, url?: string, message?: string}> => {
  try {
    const blob = await downloadMediaBlob(projectId, type);
    
    if (!blob) {
      return { 
        success: false, 
        message: "File not found or not accessible"
      };
    }
    
    const url = URL.createObjectURL(blob);
    
    return {
      success: true,
      url
    };
  } catch (err) {
    console.error(`Error in downloadMediaFile for ${type}:`, err);
    return {
      success: false,
      message: `Failed to download ${type}: ${err instanceof Error ? err.message : 'Unknown error'}`
    };
  }
};

/**
 * Deletes media files for a project
 * @param projectId - The ID of the project
 * @param userId - The ID of the user who owns the project
 * @returns Promise<boolean> - Whether the deletion was successful
 */
export const deleteMediaFile = async (projectId: string, userId: string): Promise<boolean> => {
  try {
    // First check if the user has permission
    const { data: projectData, error: projectError } = await supabase
      .from('projects')
      .select('user_id')
      .eq('id', projectId)
      .single();
      
    if (projectError || !projectData || projectData.user_id !== userId) {
      console.error("Error checking project ownership:", projectError || "User is not the owner");
      return false;
    }
    
    // Delete all files in the project folder
    const { data: files, error: listError } = await supabase
      .storage
      .from(PODCASTS_BUCKET)
      .list(projectId);
      
    if (listError) {
      console.error("Error listing files for deletion:", listError);
      return false;
    }
    
    if (files && files.length > 0) {
      const filePaths = files.map(file => `${projectId}/${file.name}`);
      
      const { error: deleteError } = await supabase
        .storage
        .from(PODCASTS_BUCKET)
        .remove(filePaths);
        
      if (deleteError) {
        console.error("Error deleting files:", deleteError);
        return false;
      }
    }
    
    return true;
  } catch (err) {
    console.error("Error deleting media files:", err);
    return false;
  }
};

/**
 * Checks if the current user session is valid
 * @returns Promise<boolean> - Whether the session is valid
 */
export const isSessionValid = async (): Promise<boolean> => {
  const { data: { session }, error } = await supabase.auth.getSession();
  
  if (error) {
    console.error("Error checking session:", error);
    return false;
  }
  
  return !!session && new Date(session.expires_at * 1000) > new Date();
};

/**
 * Refreshes the user session if needed
 * @returns Promise<boolean> - Whether the session was refreshed successfully
 */
export const refreshSession = async (): Promise<boolean> => {
  try {
    const { data: { session }, error } = await supabase.auth.getSession();
    
    if (error) {
      console.error("Error getting session:", error);
      return false;
    }
    
    if (!session) {
      console.error("No session found");
      return false;
    }
    
    // If session expires in less than 10 minutes, refresh it
    const expiresAt = new Date(session.expires_at * 1000);
    const tenMinutesFromNow = new Date(Date.now() + 10 * 60 * 1000);
    
    if (expiresAt < tenMinutesFromNow) {
      const { data, error: refreshError } = await supabase.auth.refreshSession();
      
      if (refreshError) {
        console.error("Error refreshing session:", refreshError);
        return false;
      }
      
      return !!data.session;
    }
    
    return true;
  } catch (err) {
    console.error("Error refreshing session:", err);
    return false;
  }
};
